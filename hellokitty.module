<?php
/**
 * @file
 * Text format filter to convert the word "cat" into a link to a cat image.
 */
  
 /**
  * Implements hook_filter_info()
  *
  * https://api.drupal.org/api/drupal/modules!filter!filter.api.php/function/hook_filter_info/7
  */
function hellokitty_filter_info() {
    $filters = array();
    $filters ['hellokitty'] = array(
        'title' => t('Make each occurrence of "cat" a link to a cat photo '),
	'process callback' => '_hellokitty_filter',
	'cache' => FALSE,  /* Turn off caching during development. */
    );
    return $filters;
}

/**
 * 'process callback' for hellokitty_filter to carry out the string replacements.
 */
function _hellokitty_filter($text, $filter, $format, $langcode, $cache, $cache_id) {
    $pattern = '/(\bcat\b)/i';
    $replacement = '<a href="http://www.austintexas.gov/sites/default/files/files/Animal_Services/cute-kitten-playing.jpg">${1}</a>';
    
    return _hellokitty_do_replacements($text, $pattern, $replacement);
}

/**
 * Implements an algorithm to do string replacements in an HTML snippet.
 *
 * This implementation is a tongue in cheek attempt to produce something useful. 
 *
 * First, it does a simplistic string replacement in the entire html snippet. 
 * Then it does a simplistic string replacement in the snippet after all html has been stripped. 
 * The two counts for the number of replacements are compared. 
 * If the counts are equal, that means the presence of html tags did not affect 
 * the number of replacements and we can treat the simplistic string replacement as correct.
 *
 * On the other hand, if the counts are not equal, then there was at least one match within
 * an html tag. So we scrub the process and just pass back the original text unchanged.
 */
function _hellokitty_do_replacements($text, $pattern, $replacement) {
    $converted_text = use_html_parser($text, $pattern, $replacement);
    //~ dpm("snippet: $converted_text");
    return $converted_text;
}

function use_html_parser($text, $pattern, $replacement) {
  // Load the html snippet. Ignore warnings during HTML soup loading.
  $dom_document = new DOMDocument();
  @$dom_document->loadHTML('<html><body>' . $text . '</body></html>');
  
  // Traverse the DOM tree, looking for text nodes.
  $body_node = $dom_document->getElementsByTagName('body')->item(0);
  check_children($body_node, $pattern, $replacement);

  // Serialize back to an xhtml snippet.
  $body_content = '';
  foreach ($body_node->childNodes as $child_node) {
    $body_content .= $dom_document->saveXML($child_node);
  }
  
  return preg_replace('|<([^> ]*)/>|i', '<$1 />', $body_content);
}

function check_children($parent_node, $pattern, $replacement) {
  if ($parent_node->hasChildNodes()) {
    $child = $parent_node->firstChild;
    while($child) {
      $next_child = $child->nextSibling;
      // If this child is text, process it.
      if ($child->nodeType == XML_TEXT_NODE) {
        $text = $child->nodeValue;
	
	// As a demonstration of proof of concept, for the time being,
	// Just replace the string "cat" with another string with no markup.
	$text = preg_replace($pattern, $replacement, $text);
	
	// Build a DOM tree for the replaced text, i.e. parse it.
	// This gives us a set of nodes to replace this child.
	$dom_2 = new DOMDocument();
        @$dom_2->loadHTML('<html><body>' . $text . '</body></html>');
	//~ dpm("Replaced text is: $text");
	$body_2 = $dom_2->getElementsByTagName('body')->item(0);

	$body_tmp= $parent_node->ownerDocument->importNode($body_2, TRUE);
	
	$new_children = $body_tmp->childNodes;
	//~ dpm("Number of elements: $new_children->length");
	for ($i = 0; $i <= $new_children->length -1; $i++ ) {
	  $clone = $new_children->item($i)->cloneNode(TRUE);
	  $parent_node->insertBefore($clone, $child);
	}
	$parent_node->removeChild($child);
	
        //~ dpm("Found a text node: $text");
      }
      else {
        check_children($child, $pattern, $replacement);
      }
      $child = $next_child;
    }
  }
}